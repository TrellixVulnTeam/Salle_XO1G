{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\aousw\\\\Desktop\\\\React\\\\paper-dashboard-react-main\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\aousw\\\\Desktop\\\\React\\\\paper-dashboard-react-main\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createForOfIteratorHelper.js\").default;\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\aousw\\\\Desktop\\\\React\\\\paper-dashboard-react-main\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\toConsumableArray.js\").default;\n\nvar isFullwidthCodePoint = require('is-fullwidth-code-point');\n\nvar astralRegex = require('astral-regex');\n\nvar ansiStyles = require('ansi-styles');\n\nvar ESCAPES = [\"\\x1B\", \"\\x9B\"];\n\nvar wrapAnsi = function wrapAnsi(code) {\n  return \"\".concat(ESCAPES[0], \"[\").concat(code, \"m\");\n};\n\nvar checkAnsi = function checkAnsi(ansiCodes, isEscapes, endAnsiCode) {\n  var output = [];\n  ansiCodes = _toConsumableArray(ansiCodes);\n\n  var _iterator = _createForOfIteratorHelper(ansiCodes),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ansiCode = _step.value;\n      var ansiCodeOrigin = ansiCode;\n\n      if (ansiCode.includes(';')) {\n        ansiCode = ansiCode.split(';')[0][0] + '0';\n      }\n\n      var item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));\n\n      if (item) {\n        var indexEscape = ansiCodes.indexOf(item.toString());\n\n        if (indexEscape === -1) {\n          output.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));\n        } else {\n          ansiCodes.splice(indexEscape, 1);\n        }\n      } else if (isEscapes) {\n        output.push(wrapAnsi(0));\n        break;\n      } else {\n        output.push(wrapAnsi(ansiCodeOrigin));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (isEscapes) {\n    output = output.filter(function (element, index) {\n      return output.indexOf(element) === index;\n    });\n\n    if (endAnsiCode !== undefined) {\n      var fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));\n      output = output.reduce(function (current, next) {\n        return next === fistEscapeCode ? [next].concat(_toConsumableArray(current)) : [].concat(_toConsumableArray(current), [next]);\n      }, []);\n    }\n  }\n\n  return output.join('');\n};\n\nmodule.exports = function (string, begin, end) {\n  var characters = _toConsumableArray(string);\n\n  var ansiCodes = [];\n  var stringEnd = typeof end === 'number' ? end : characters.length;\n  var isInsideEscape = false;\n  var ansiCode;\n  var visible = 0;\n  var output = '';\n\n  var _iterator2 = _createForOfIteratorHelper(characters.entries()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          index = _step2$value[0],\n          character = _step2$value[1];\n\n      var leftEscape = false;\n\n      if (ESCAPES.includes(character)) {\n        var code = /\\d[^m]*/.exec(string.slice(index, index + 18));\n        ansiCode = code && code.length > 0 ? code[0] : undefined;\n\n        if (visible < stringEnd) {\n          isInsideEscape = true;\n\n          if (ansiCode !== undefined) {\n            ansiCodes.push(ansiCode);\n          }\n        }\n      } else if (isInsideEscape && character === 'm') {\n        isInsideEscape = false;\n        leftEscape = true;\n      }\n\n      if (!isInsideEscape && !leftEscape) {\n        visible++;\n      }\n\n      if (!astralRegex({\n        exact: true\n      }).test(character) && isFullwidthCodePoint(character.codePointAt())) {\n        visible++;\n\n        if (typeof end !== 'number') {\n          stringEnd++;\n        }\n      }\n\n      if (visible > begin && visible <= stringEnd) {\n        output += character;\n      } else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {\n        output = checkAnsi(ansiCodes);\n      } else if (visible >= stringEnd) {\n        output += checkAnsi(ansiCodes, true, ansiCode);\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return output;\n};","map":{"version":3,"sources":["C:/Users/aousw/Desktop/React/paper-dashboard-react-main/node_modules/slice-ansi/index.js"],"names":["isFullwidthCodePoint","require","astralRegex","ansiStyles","ESCAPES","wrapAnsi","code","checkAnsi","ansiCodes","isEscapes","endAnsiCode","output","ansiCode","ansiCodeOrigin","includes","split","item","codes","get","Number","parseInt","indexEscape","indexOf","toString","push","splice","filter","element","index","undefined","fistEscapeCode","reduce","current","next","join","module","exports","string","begin","end","characters","stringEnd","length","isInsideEscape","visible","entries","character","leftEscape","exec","slice","exact","test","codePointAt"],"mappings":"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","sourcesContent":["'use strict';\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst astralRegex = require('astral-regex');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = [\n\t'\\u001B',\n\t'\\u009B'\n];\n\nconst wrapAnsi = code => `${ESCAPES[0]}[${code}m`;\n\nconst checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {\n\tlet output = [];\n\tansiCodes = [...ansiCodes];\n\n\tfor (let ansiCode of ansiCodes) {\n\t\tconst ansiCodeOrigin = ansiCode;\n\t\tif (ansiCode.includes(';')) {\n\t\t\tansiCode = ansiCode.split(';')[0][0] + '0';\n\t\t}\n\n\t\tconst item = ansiStyles.codes.get(Number.parseInt(ansiCode, 10));\n\t\tif (item) {\n\t\t\tconst indexEscape = ansiCodes.indexOf(item.toString());\n\t\t\tif (indexEscape === -1) {\n\t\t\t\toutput.push(wrapAnsi(isEscapes ? item : ansiCodeOrigin));\n\t\t\t} else {\n\t\t\t\tansiCodes.splice(indexEscape, 1);\n\t\t\t}\n\t\t} else if (isEscapes) {\n\t\t\toutput.push(wrapAnsi(0));\n\t\t\tbreak;\n\t\t} else {\n\t\t\toutput.push(wrapAnsi(ansiCodeOrigin));\n\t\t}\n\t}\n\n\tif (isEscapes) {\n\t\toutput = output.filter((element, index) => output.indexOf(element) === index);\n\n\t\tif (endAnsiCode !== undefined) {\n\t\t\tconst fistEscapeCode = wrapAnsi(ansiStyles.codes.get(Number.parseInt(endAnsiCode, 10)));\n\t\t\toutput = output.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);\n\t\t}\n\t}\n\n\treturn output.join('');\n};\n\nmodule.exports = (string, begin, end) => {\n\tconst characters = [...string];\n\tconst ansiCodes = [];\n\n\tlet stringEnd = typeof end === 'number' ? end : characters.length;\n\tlet isInsideEscape = false;\n\tlet ansiCode;\n\tlet visible = 0;\n\tlet output = '';\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tlet leftEscape = false;\n\n\t\tif (ESCAPES.includes(character)) {\n\t\t\tconst code = /\\d[^m]*/.exec(string.slice(index, index + 18));\n\t\t\tansiCode = code && code.length > 0 ? code[0] : undefined;\n\n\t\t\tif (visible < stringEnd) {\n\t\t\t\tisInsideEscape = true;\n\n\t\t\t\tif (ansiCode !== undefined) {\n\t\t\t\t\tansiCodes.push(ansiCode);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isInsideEscape && character === 'm') {\n\t\t\tisInsideEscape = false;\n\t\t\tleftEscape = true;\n\t\t}\n\n\t\tif (!isInsideEscape && !leftEscape) {\n\t\t\tvisible++;\n\t\t}\n\n\t\tif (!astralRegex({exact: true}).test(character) && isFullwidthCodePoint(character.codePointAt())) {\n\t\t\tvisible++;\n\n\t\t\tif (typeof end !== 'number') {\n\t\t\t\tstringEnd++;\n\t\t\t}\n\t\t}\n\n\t\tif (visible > begin && visible <= stringEnd) {\n\t\t\toutput += character;\n\t\t} else if (visible === begin && !isInsideEscape && ansiCode !== undefined) {\n\t\t\toutput = checkAnsi(ansiCodes);\n\t\t} else if (visible >= stringEnd) {\n\t\t\toutput += checkAnsi(ansiCodes, true, ansiCode);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn output;\n};\n"]},"metadata":{},"sourceType":"script"}